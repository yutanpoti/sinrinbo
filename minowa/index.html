
<html lang="ja">
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <title>箕輪ちいもりず_2025.9森林簿</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="index.css" />
    <link rel="stylesheet" href="table.css" />
    <script src="https://unpkg.com/underscore@1.13.1/underscore-min.js"></script>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/flatgeobuf@3.22.0/dist/flatgeobuf-geojson.min.js"></script>
    <script src="https://unpkg.com/json-formatter-js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
      }
      #map {
        height: 100%;
        width: 100%;
      }
      #basemap-controls {
        font-size: 24px;
        line-height: 2.2;
      }
      #basemap-controls input[type="radio"] {
        width: 20px;
        height: 22px;
        margin-right: 5px;
      }
      .leaflet-popup-content {
        font-size: 18px;
        line-height: 1.6;
        padding: 5px;
      }
      .leaflet-popup-content-wrapper {
        max-width: 800px;
        padding: 5px;
      }
      .leaflet-popup-tip {
        width: 20px;
        height: 20px;
      }

      /* もともとのスタイルをクラス化 */
      .layer-controls {
          position: absolute;
          top: 25px;/* 1.25倍の影響でズレたので調整 */
          left: 15px;
          font-size: 20px;
          transform: scale(1.25);  /* 元のサイズの1.25倍に拡大 */
          background: white;
          padding: 10px;
          z-index: 1000;
          border: 1px solid #ccc;
          border-radius: 5px;
          /* デフォルトの行間（スマホ/PCどちらでも上書きされる） */
          line-height: 2.2;
      }

      .style-controls {
          position: absolute;
          top: 5px;
          right: 5px;
          transform: translateX(-50%);
          background: white;
          font-size: 24px;
          padding: 10px;
          border-radius: 5px;
          z-index: 1000;
          border: 3px solid blue;
          /* デフォルトの行間（スマホ/PCどちらでも上書きされる） */
          line-height: 1.8;
      }

      .style-radio-group {
          display: flex;
          flex-wrap: wrap;
          gap: 10px;
          max-width: 500px;
      }

      /* ラジオボタンそのものを大きく表示する */
      .style-controls input[type="radio"] {
          transform: scale(1.5);  /* 元のサイズの1.5倍に拡大 */
          margin-right: 5px;       /* 隣との間隔を少し確保 */
      }

      /* スマートフォン用（画面幅768px以下の場合）：行間
      @media (max-width: 768px) {
          .layer-controls,
          .style-controls {
              line-height: 1.6;
          }
      } */

      /* PC用（画面幅769px以上の場合）：行間
      @media (min-width: 769px) {
          .layer-controls,
          .style-controls {
              line-height: 1.6;
          }
      } */

      /* 中心の十字マーク（赤いクロス） */
      .crosshair {
        position: absolute;
        top: 50%;      /* 画面の上下中央に配置 */
        left: 50%;     /* 画面の左右中央に配置 */
        width: 20px;
        height: 20px;
        pointer-events: none; /* この要素をクリックしても地図操作を邪魔しない */
        transform: translate(-50%, -50%); /* 中心基準に配置 */
        z-index: 9999; /* ✅ 地図よりも前面に表示（最重要ポイント） */
      }

      /* 十字マークを構成する線のスタイル */
      .crosshair::before, .crosshair::after {
        content: '';
        position: absolute;
        background: red; /* 線の色（赤） */
      }

      /* 十字の縦線 */
      .crosshair::before {
        width: 2px;
        height: 20px;
        left: 9px;
        top: 0;
      }

      /* 十字の横線 */
      .crosshair::after {
        width: 20px;
        height: 2px;
        top: 9px;
        left: 0;
      }

      /* 座標コピー用ボタン */
      #copyBtn {
        position: absolute;
        bottom: 130px;
        left: 10px;
        z-index: 1000; /* 地図の上に表示するため */
        font-size: 24px;
        color: red;
        padding: 8px 12px;
        background: white;
        border: 2px solid red;
        border-radius: 5px;
        cursor: pointer;
      }

      /* 中心座標の表示ウインドウ */
      #coordDisplay {
        position: absolute;
        bottom: 100px;
        left: 10px;
        background: rgba(255,255,255,0.9);
        border: 2px solid red;
        border-radius: 5px;
        padding: 6px 10px;
        font-family: monospace;
        z-index: 1000;
      }


    </style>
  </head>
  <body>
    <div id="map"></div>

    <!-- 中心の十字マーク（常に最前面で表示） -->
    <div class="crosshair"></div>

    <!-- 現在の地図中心座標をコピーするボタン -->
    <button id="copyBtn">中心座標をコピー</button>

    <!-- 地図の中心座標を常時表示するウインドウ -->
    <div id="coordDisplay">
      中心座標：<span id="lat">0</span>, <span id="lng">0</span>
    </div>

    <!-- 指定座標へ移動ボタン -->
    <button id="gotoBtn" style="
      position: absolute;
      bottom: 190px;
      left: 10px;
      z-index: 1000;
      font-size: 24px;
      padding: 8px 12px;
      background: white;
      border: 2px solid #888;
      border-radius: 5px;
      cursor: pointer;
    ">
      指定座標へ移動
    </button>

    <!-- カスタムモーダル -->
    <div id="coordModal" style="
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.3);
      z-index: 2000;
      justify-content: center;
      align-items: center;
      font-size: 24px; /* ← モーダル全体の文字も大きめに */
    ">
      <div style="
        background: white;
        border-radius: 8px;
        padding: 20px;
        width: 280px; /* 少し広げて見やすく */
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      ">
        <p><b>座標を入力</b></p>
        <p style="font-size: 20px;">（例：36.123456, 138.123456）</p>
        <input id="coordInput" type="text" placeholder="緯度, 経度"
          style="width:100%; padding:8px; font-size:40px; line-height:1.4; margin-top:4px;"><br><br>
        <div style="text-align:right;">
          <button id="cancelBtn" style="font-size:30px;">取消</button>
          <button id="moveBtn" style="font-size:30px;">移動</button>
        </div>
      </div>
    </div>

    <!-- レイヤコントロール -->
    <div class="layer-controls">
      <label class="forest-label"><input type="checkbox" id="forestLayerToggle" checked> 森林簿</label><br>
      <label><input type="checkbox" id="cadastralLayerToggle"> 地籍図</label><br>
      <label><input type="checkbox" id="hazardLayerToggle"> ハザード</label><br>
      <label><input type="checkbox" id="viewpointLayerToggle"> 見どころ</label><br>
      <label><input type="checkbox" id="roadLayerToggle"> 路網</label>
    </div>

    <!-- 現在地追跡ボタン -->
    <button id="gpsButton" style="position: absolute; bottom: 30px; left: 10px; z-index: 1000; font-size: 30px; padding: 10px 15px; border: 2px solid #007bff; border-radius: 5px; background-color: #ffffff; color: #007bff; cursor: pointer;">現在地追跡 ON</button>

    <!-- 背景地図切り替えのボタン -->
    <div id="basemap-controls" style="position: absolute; top: 5px; right: 10px; background: white; padding: 10px; z-index: 1000; border: 1px solid #ccc; border-radius: 5px;">
      <label><input type="radio" name="basemap" value="地理院タイル淡色地図" checked> 地理院淡色地図</label><br>
      <label><input type="radio" name="basemap" value="ベースマップ航空写真"> 航空写真</label><br>
      <label><input type="radio" name="basemap" value="1970年代写真"> 1970年代写真</label><br>
      <label><input type="radio" name="basemap" value="長野県CS立体図"> 長野県CS立体図</label><br>
      <label><input type="radio" name="basemap" value="シームレス地質図V2"> シームレス地質図</label>
    </div>

    <!-- スタイル選択用ラジオボタン -->
    <div class="style-controls">
      <div class="style-radio-group">    
        <label style="flex: 1 1 45%;"><input type="radio" name="style" value="L_林班"> 林班</label>
        <label style="flex: 1 1 45%;"><input type="radio" name="style" value="L_樹種_1" checked> 樹種_1・林齢</label>
        <label style="flex: 1 1 45%;"><input type="radio" name="style" value="L_森林経営計画"> 森林経営計画</label>
        <label style="flex: 1 1 45%;"><input type="radio" name="style" value="L_アカマツHA材積"> アカマツHA材積</label>
        <label style="flex: 1 1 45%;"><input type="radio" name="style" value="L_一体整備相当区域"> 一体整備相当区域</label>
        <label style="flex: 1 1 45%;"><input type="radio" name="style" value="L_カラマツHA材積"> カラマツHA材積</label>
        <label style="flex: 1 1 45%;"><input type="radio" name="style" value="L_施業種"> 施業種・保安林</label>
        <label style="flex: 1 1 45%;"><input type="radio" name="style" value="L_ヒノキHA材積"> ヒノキHA材積</label>
        <label style="flex: 1 1 45%;"><input type="radio" name="style" value="L_施業履歴1_除間伐"> 除間伐履歴</label>
        <label style="flex: 1 1 45%;"><input type="radio" name="style" value="L_スギHA材積"> スギHA材積</label>
      </div>
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", async () => {
        // 1. 地図の初期化とベースマップの設定
        let map = L.map("map", {
            minZoom: 10    // ズーム下限
        }).setView([35.9462335, 137.9968015], 16);//めも：北小河内中心に変更
        
        const baseMaps = {
          "地理院タイル淡色地図": L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png", {
            attribution:
              '<a href="https://www.gsi.go.jp/development/ichiran.html#pale">地理院タイル淡色地図</a>&copy; <a href="https://www.gsi.go.jp/kikakuchousei/kikakuchousei40182.html">国土地理院</a>|<a href="https://www.pref.nagano.lg.jp/rinsei/sangyo/ringyo/seibi/shisan.html">長野県森林情報</a>&copy; <a href="https://www.pref.nagano.lg.jp/index.html">長野県</a>',
              maxNativeZoom: 18,  // タイルが存在する最大ズーム
              minNativeZoom: 5,   // タイルが存在する最小ズーム
          }),
          "ベースマップ航空写真": L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/seamlessphoto/{z}/{x}/{y}.jpg', {
              attribution: '<a href="https://www.gsi.go.jp/common/000225818.pdf">国土地理院 航空写真</a>&copy; <a href="https://www.gsi.go.jp/">国土地理院</a>',
              maxNativeZoom: 18,  // タイルが存在する最大ズーム
              minNativeZoom: 14,   // タイルが存在する最小ズーム
          }),
          "1970年代写真": L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/gazo1/{z}/{x}/{y}.jpg', {
              attribution: '<a href="https://www.gsi.go.jp/common/000225818.pdf">国土地理院 航空写真（1970年代）</a>&copy; <a href="https://www.gsi.go.jp/">国土地理院</a>',
              maxNativeZoom: 17,  // タイルが存在する最大ズーム
              minNativeZoom: 10,   // タイルが存在する最小ズーム
          }),
          "長野県CS立体図": L.tileLayer('https://tile.geospatial.jp/CS/VER2/{z}/{x}/{y}.png', {
              attribution: '<a href="https://www.geospatial.jp/">長野県CS立体図</a>',
              maxNativeZoom: 18,  // タイルが存在する最大ズーム
              minNativeZoom: 8,   // タイルが存在する最小ズーム
          }),
          "シームレス地質図V2": L.tileLayer('https://gbank.gsj.jp/seamless/v2/api/1.2/tiles/{z}/{y}/{x}.png', {
              attribution: '<a href="https://gbank.gsj.jp/seamless/index.html">産総研 地質図</a>&copy; <a href="https://www.gsj.jp/">産総研</a>',
              maxNativeZoom: 13,  // タイルが存在する最大ズーム
              minNativeZoom: 0,   // タイルが存在する最小ズーム
          })
        };

        // 初期のベースマップを設定
        baseMaps["地理院タイル淡色地図"].addTo(map);

        // ベースマップの切り替え機能
        document.getElementById('basemap-controls').addEventListener('change', (e) => {
            if (e.target.name === 'basemap') {
                // 選択された背景地図を取得して切り替え
                Object.values(baseMaps).forEach(layer => map.removeLayer(layer));
                baseMaps[e.target.value].addTo(map);
            }
        });


        // 2. バウンディングボックス作成
        function getBoundForRect() {
          const bounds = map.getBounds();
          const width = map.distance(bounds.getNorthWest(), bounds.getNorthEast());
          const height = map.distance(bounds.getNorthWest(), bounds.getSouthWest());
          return map.getCenter().toBounds(Math.min(width, height) * 0.8);
        }
        function fgBoundingBox() {
          const bounds = getBoundForRect();
          return {
            minX: bounds.getWest(),
            maxX: bounds.getEast(),
            minY: bounds.getSouth(),
            maxY: bounds.getNorth(),
          };
        }
        let rectangle = L.rectangle(getBoundForRect(), { interactive: false, color: "blue", fillOpacity: 0.0, opacity: 1.0 }).addTo(map);

        // 3. 共通のスタイル定義（forestLayerなど用）
        const colorScale = (d) => {
          const colors =  ["#FF0000","#00FFFF","#66FF00","#9900FF","#FFCC00","#0033FF","#00FF66","#FF0099","#CCFF00","#3300FF","#FF6600","#0099FF","#00FF00","#FF00FF","#FFFF00","#0000FF","#00FFCC","#FF0033","#99FF00","#6600FF","#FF3300","#00CCFF","#33FF00","#CC00FF","#FF9900","#0066FF","#00FF33","#FF00CC","#00FF99","#FF0066"];
          const index = parseInt(d, 10) % 30;
          return colors[index] || "#000000";
        };
        const styles = {
          "L_林班": (feature) => ({
            color: colorScale(feature.properties["L_林班"]),
            weight: 1,
            fillOpacity: 0.4,
          }),
          "L_森林経営計画": (feature) => {
            const value = feature.properties["L_森林経営計画"];
            return {
              color: value == 1 ? "blue" : "gray",
              weight: 1,
              fillOpacity: value == 1 ? 0.4 : 0.2,
            };
          },
          "L_施業種": (feature) => {
            const colors = { 1: "red", 2: "orange", 3: "yellow", 4: "green", 5: "blue" };
            const baseColor = colors[feature.properties["L_施業種"]] || "gray";
            // 「L_保安林1」と「L_保安林2」のいずれも値がない場合は細い線（0.5）、それ以外は太い線（5）
            const weight = (!feature.properties["L_保安林1"] && !feature.properties["L_保安林2"]) ? 0.5 : 5;
            return {
              color: baseColor,
              weight: weight,
              fillOpacity: 0.4,
            };
          },
          "L_樹種_1": (feature) => {
            const colors = {
              アカマツ: "red",
              カラマツ: "orange",
              ヒノキ: "darkgreen",
              サワラ: "lightgreen",
              スギ: "blue",
              その他広: "yellow",
            };
            return {
              color: colors[feature.properties["L_樹種_1"]] || "gray",
              weight: 1,
              fillOpacity: +feature.properties["L_林齢_1"] < 40 ? 0.2 : (+feature.properties["L_林齢_1"] < 80 ? 0.4 : 0.6),
            };
          },
          "枠のみ": (feature) => ({
            color: "black",
            weight: 1, //細い線で、透明度0.0
            fillOpacity: 0.0,
          }),
          "L_一体整備相当区域": (feature) => {
            const value = feature.properties["L_一体整備相当区域"];
            return {
              color: value == 1 ? "yellow" : "gray",
              weight: 1,//細い線で。該当しない場合は、透明度0.0
              fillOpacity: value == 1 ? 0.4 : 0.0,
            };
          },
          "L_施業履歴1_除間伐": (feature) => {
            const value = feature.properties["L_施業履歴1_除間伐"];
            let fillOpacity = 0.0;
            if (value > 2005 && value < 2010) fillOpacity = 0.2;
            else if (value >= 2010 && value < 2015) fillOpacity = 0.4;
            else if (value >= 2015 && value < 2020) fillOpacity = 0.6;
            else if (value >= 2020) fillOpacity = 0.8;
            return {
              color: "green",
              weight: 0.1,
              fillOpacity: fillOpacity,
            };
          },            
          "L_アカマツHA材積": (feature) => {
            const value = feature.properties["L_アカマツHA材積"];
            let fillOpacity = 0.0;
            if (value > 0 && value < 100) fillOpacity = 0.2;
            else if (value >= 100 && value < 200) fillOpacity = 0.4;
            else if (value >= 200 && value < 300) fillOpacity = 0.6;
            else if (value >= 300) fillOpacity = 0.8;
            return {
              color: "red",
              weight: 0.1,
              fillOpacity: fillOpacity,
            };
          },
          "L_カラマツHA材積": (feature) => {
            const value = feature.properties["L_カラマツHA材積"];
            let fillOpacity = 0.0;
            if (value > 0 && value < 100) fillOpacity = 0.2;
            else if (value >= 100 && value < 200) fillOpacity = 0.4;
            else if (value >= 200 && value < 300) fillOpacity = 0.6;
            else if (value >= 300) fillOpacity = 0.8;
            return {
              color: "orange",
              weight: 0.1,
              fillOpacity: fillOpacity,
            };
          },
          "L_ヒノキHA材積": (feature) => {
            const value = feature.properties["L_ヒノキHA材積"];
            let fillOpacity = 0.0;
            if (value > 0 && value < 100) fillOpacity = 0.2;
            else if (value >= 100 && value < 200) fillOpacity = 0.4;
            else if (value >= 200 && value < 300) fillOpacity = 0.6;
            else if (value >= 300) fillOpacity = 0.8;
            return {
              color: "darkgreen",
              weight: 0.1,
              fillOpacity: fillOpacity,
            };
          },
          "L_スギHA材積": (feature) => {
            const value = feature.properties["L_スギHA材積"];
            let fillOpacity = 0.0;
            if (value > 0 && value < 100) fillOpacity = 0.2;
            else if (value >= 100 && value < 200) fillOpacity = 0.4;
            else if (value >= 200 && value < 300) fillOpacity = 0.6;
            else if (value >= 300) fillOpacity = 0.8;
            return {
              color: "blue",
              weight: 0.1,
              fillOpacity: fillOpacity,
            };
          },
          "L_広葉樹HA材積": (feature) => {
            const value = feature.properties["L_広葉樹HA材積"];
            let fillOpacity = 0.0;
            if (value > 0 && value < 100) fillOpacity = 0.2;
            else if (value >= 100 && value < 200) fillOpacity = 0.4;
            else if (value >= 200 && value < 300) fillOpacity = 0.6;
            else if (value >= 300) fillOpacity = 0.8;
            return {
              color: "yellow",
              weight: 0.1,
              fillOpacity: fillOpacity,
            };
          },
        };

        // ポップアップ用のnullチェック関数。「UNDEFINED」と表示されないようにするため
        function getValue(value, defaultValue = "-") {
          return value ?? defaultValue;
        }

        // 4. 各FGBレイヤの定義
        // ※ここでは、forestLayer、cadastralLayer、hazardLayer、viewpointLayer、roadLayer の5件を実装
        const layers = {
          // 4-1. 森林簿（forestLayer）
          forest: {
            url: "https://yutanpoti.github.io/sinrinbo/minowa/sinrinbo202509_minowa_mini.fgb",
            // 初期表示はチェックONのため、layerGroupをすぐにマップへ追加
            layerGroup: L.layerGroup().addTo(map),
            update: async function () {
              this.layerGroup.clearLayers();
              const selectedStyle = document.querySelector('input[name="style"]:checked').value;
              const iter = flatgeobuf.deserialize(this.url, fgBoundingBox());
              for await (const feature of iter) {
                const style = styles[selectedStyle](feature);
                L.geoJSON(feature, { style: style })
                  .on({
                    mouseover: function (e) {
                      e.target.setStyle({
                        weight: 4,
                        fillOpacity: 0.8,
                      });
                    },
                    mouseout: function (e) {
                      e.target.setStyle(style);
                    },
                  })
                  .bindPopup(
                    `林班名：${getValue(feature.properties["L_林班"])}-${getValue(feature.properties["L_小班"])}-${getValue(feature.properties["L_施業番号"])}-${getValue(feature.properties["L_枝番"])}、面積：${getValue(feature.properties["L_面積_1"])}ha<br />
                     経営計画：${getValue(feature.properties["L_森林経営計画"])}、　一体整備相当：${getValue(feature.properties["L_一体整備相当区域"])}<br />
                     徐間伐履歴：${getValue(feature.properties["L_施業履歴1_除間伐"])}、　その他履歴：${getValue(feature.properties["L_施業履歴1_その他"])}<br />
                     保安林：${getValue(feature.properties["L_保安林1"])}・${getValue(feature.properties["L_施業方法_保安林1"])},
                     ${getValue(feature.properties["L_保安林2"])}・${getValue(feature.properties["L_施業方法_保安林2"])},
                     ${getValue(feature.properties["L_保安林3"])}・${getValue(feature.properties["L_施業方法_保安林3"])}<br />
                     施業種：${getValue(feature.properties["L_施業種"])}（皆・10・長・複・択）<br />
                     効率区域：${getValue(feature.properties["L_効率的施業区域"])}、植栽更新：${getValue(feature.properties["L_植栽更新森林"])}<br />
                     樹種_1：${getValue(feature.properties["L_樹種_1"])}、
                     ${getValue(feature.properties["L_林齢_1"])}年、
                     ${getValue(feature.properties["L_材積_1"])}m3、
                     (${getValue(feature.properties["L_HA材積_1"])}m3/ha)<br />
                     樹種_2：${getValue(feature.properties["L_樹種_2"])}、
                     ${getValue(feature.properties["L_林齢_2"])}年、
                     ${getValue(feature.properties["L_材積_2"])}m3、
                     (${getValue(feature.properties["L_HA材積_2"])}m3/ha)<br />
                     樹種_3：${getValue(feature.properties["L_樹種_3"])}、
                     ${getValue(feature.properties["L_林齢_3"])}年、
                     ${getValue(feature.properties["L_材積_3"])}m3、
                     (${getValue(feature.properties["L_HA材積_3"])}m3/ha)<br />`
                  )
                  .addTo(this.layerGroup);
              }
              rectangle.bringToFront();
            },
          },
          // 4-2. 地籍図（cadastralLayer）
          cadastral: {
            url: "https://habs.rad.naro.go.jp/spatial_data/amxpoly47/amxpoly_2022_20.fgb",
            layerGroup: L.layerGroup(), // 初期はチェックOFFなので、マップへは後で追加
            update: async function () {
              this.layerGroup.clearLayers();
              const iter = flatgeobuf.deserialize(this.url, fgBoundingBox());
              for await (const feature of iter) {
                // シンプルな紫色のアウトライン
                const style = { color: "purple", weight: 3, fillOpacity: 0.1 };
                // ポップアップ：市区町村名、大字名、丁目名、小字名、地番を表示
                const popupContent = `市区町村名：${getValue(feature.properties["市区町村名"])}<br />
                                      大字名：${getValue(feature.properties["大字名"])}<br />
                                      丁目名：${getValue(feature.properties["丁目名"])}<br />
                                      小字名：${getValue(feature.properties["小字名"])}<br />
                                      地番：${getValue(feature.properties["地番"])}`;
                L.geoJSON(feature, { style: style })
                  .bindPopup(popupContent)
                  .addTo(this.layerGroup);
              }
            },
          },
          // 4-3. ハザード（hazardLayer）
          hazard: {
            url: "https://yutanpoti.github.io/sinrinbo/FGB/hazard_merge.fgb",
            layerGroup: L.layerGroup(),
            update: async function () {
              this.layerGroup.clearLayers();
              const iter = flatgeobuf.deserialize(this.url, fgBoundingBox());
              for await (const feature of iter) {
                // 属性['layer'] によって色分け
                const layerValue = feature.properties["layer"];
                let color;
                switch (layerValue) {
                  case "kyuukeisha":
                    color = "pink";
                    break;
                  case "red":
                    color = "red";
                    break;
                  case "yellow":
                    color = "yellow";
                    break;
                  case "santi_houkai":
                    color = "orange";
                    break;
                  case "santi_jisuberi":
                    color = "purple";
                    break;
                  case "santi_ryuushutu_bufffgb":
                    color = "brown";
                    break;
                  default:
                    color = "black";
                }
                const style = { color: color, weight: 3, fillOpacity: 0.1 };
                // ハザードはポップアップなし
                L.geoJSON(feature, { style: style }).addTo(this.layerGroup);
              }
            },
          },
          // 4-4. 見どころ（viewpointLayer）
          viewpoint: {
            url: "https://yutanpoti.github.io/sinrinbo/FGB/viewpoint.fgb",
            layerGroup: L.layerGroup(),
            update: async function () {
              this.layerGroup.clearLayers();
              const iter = flatgeobuf.deserialize(this.url, fgBoundingBox());
              for await (const feature of iter) {
                // ポイントデータの場合、属性「category」に応じた色で表示
                const geojsonOptions = {
                  pointToLayer: function (feature, latlng) {
                    // カテゴリに応じた色の設定
                    const categoryColorMap = {
                      "遺跡": "purple",
                      "森林公園": "green",
                      "巨樹": "brown",
                      "ナイス": "yellow"
                    };
                    const color = categoryColorMap[feature.properties.category] || "white";
                    return L.circleMarker(latlng, {
                      radius: 24,           // やや大きめの円
                      fillColor: color,     // categoryに応じた色
                      color: color,
                      weight: 1,
                      fillOpacity: 1,
                    });
                  },
                  onEachFeature: function (feature, layer) {
                    // 全属性表示。属性名が「linkURL」の場合、リンクを新規タブで開く
                    let popupContent = "";
                    for (const [key, value] of Object.entries(feature.properties)) {
                      if (key === "linkURL") {
                        popupContent += `${key}: <a href="${value}" target="_blank">${value}</a><br />`;
                      } else {
                        popupContent += `${key}: ${value}<br />`;
                      }
                    }
                    layer.bindPopup(popupContent);
                  },
                };
                L.geoJSON(feature, geojsonOptions).addTo(this.layerGroup);
              }
            },
          },
          // 4-5. 路網（roadLayer）
          road: {
            url: "https://yutanpoti.github.io/sinrinbo/FGB/road.fgb",
            layerGroup: L.layerGroup(),
            update: async function () {
              this.layerGroup.clearLayers();
              const iter = flatgeobuf.deserialize(this.url, fgBoundingBox());
              for await (const feature of iter) {
                // 灰色のシンプルな線で表示
                const style = { color: "gray", weight: 1, fillOpacity: 0.0 };
                L.geoJSON(feature, { style: style }).addTo(this.layerGroup);
              }
            },
          },
        };

        // 5. マップ移動時などに各レイヤのデータを更新（更新頻度は1秒に1回に制限）
        const updateForestLayerThrottled = _.throttle(() => {
          layers.forest.update();
        }, 1000);
        const updateCadastralLayerThrottled = _.throttle(() => {
          layers.cadastral.update();
        }, 1000);
        const updateHazardLayerThrottled = _.throttle(() => {
          layers.hazard.update();
        }, 1000);
        const updateViewpointLayerThrottled = _.throttle(() => {
          layers.viewpoint.update();
        }, 1000);
        const updateRoadLayerThrottled = _.throttle(() => {
          layers.road.update();
        }, 1000);

        // 初回更新：チェックされているレイヤのみ update() を実行
        if(document.getElementById("forestLayerToggle").checked) { layers.forest.update(); }
        if(document.getElementById("cadastralLayerToggle").checked) { layers.cadastral.update(); }
        if(document.getElementById("hazardLayerToggle").checked) { layers.hazard.update(); }
        if(document.getElementById("viewpointLayerToggle").checked) { layers.viewpoint.update(); }
        if(document.getElementById("roadLayerToggle").checked) { layers.road.update(); }

        // 地図移動時（moveend）の更新：チェックされているレイヤのみ update() を実行
        map.on("moveend", function() {
          rectangle.setBounds(getBoundForRect());
          if(document.getElementById("forestLayerToggle").checked) { updateForestLayerThrottled(); }
          if(document.getElementById("cadastralLayerToggle").checked) { updateCadastralLayerThrottled(); }
          if(document.getElementById("hazardLayerToggle").checked) { updateHazardLayerThrottled(); }
          if(document.getElementById("viewpointLayerToggle").checked) { updateViewpointLayerThrottled(); }
          if(document.getElementById("roadLayerToggle").checked) { updateRoadLayerThrottled(); }
        });

        // 6. ラジオボタン変更時は forestLayer のスタイル更新
        document.querySelectorAll('input[name="style"]').forEach((radio) => {
          radio.addEventListener("change", () => {
            layers.forest.update();
          });
        });

        // 7. レイヤコントロール：チェックボックスによる表示／非表示切替
        document.getElementById("forestLayerToggle").addEventListener("change", function () {
          if (this.checked) {
            layers.forest.layerGroup.addTo(map);
            layers.forest.update();
          } else {
            map.removeLayer(layers.forest.layerGroup);
          }
        });
        document.getElementById("cadastralLayerToggle").addEventListener("change", function () {
          if (this.checked) {
            layers.cadastral.layerGroup.addTo(map);
            layers.cadastral.update();
          } else {
            map.removeLayer(layers.cadastral.layerGroup);
          }
        });
        document.getElementById("hazardLayerToggle").addEventListener("change", function () {
          if (this.checked) {
            layers.hazard.layerGroup.addTo(map);
            layers.hazard.update();
          } else {
            map.removeLayer(layers.hazard.layerGroup);
          }
        });
        document.getElementById("viewpointLayerToggle").addEventListener("change", function () {
          if (this.checked) {
            layers.viewpoint.layerGroup.addTo(map);
            layers.viewpoint.update();
          } else {
            map.removeLayer(layers.viewpoint.layerGroup);
          }
        });
        document.getElementById("roadLayerToggle").addEventListener("change", function () {
          if (this.checked) {
            layers.road.layerGroup.addTo(map);
            layers.road.update();
          } else {
            map.removeLayer(layers.road.layerGroup);
          }
        });

        // ======================================
        // 10. XYZタイルオーバーレイ（標高帯・もりぞん）左別枠配置版
        // ======================================

        // 読み込みたいレイヤのURLを定義。（追加するときはここにカンマ区切りで足していけばOK。行が増えていく。）
        const xyzOverlays = {
          "標高帯": "https://yutanpoti.github.io/sinrinbo/XYZ/height_945_1063/{z}/{x}/{y}.png",
         // "もりぞん": "https://yutanpoti.github.io/sinrinbo/XYZ/morizon_minamiminowa/{z}/{x}/{y}.png"
        };

        // 実際に地図に追加されたレイヤを管理するオブジェクト
        const activeXYZ = {};

        // Leafletコントロールとして右下に配置
        const xyzControl = L.control({ position: 'topleft' });

        xyzControl.onAdd = function () {
          // コントロール用のdivを作成
          const div = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');
          div.style.background = 'white';
          div.style.padding = '10px';
          div.style.border = '1px solid #ccc';
          div.style.borderRadius = '6px';
          div.style.fontSize = '24px';
          div.style.lineHeight = '1.8';
          div.style.marginTop = '225px'; // 左上端から少しずらす

          // 各レイヤ用のチェックボックスを作成
          for (const name in xyzOverlays) {
            const id = `chk-xyz-${name}`;
            div.innerHTML += `
              <label style="display:block; margin:4px 0;">
                <input type="checkbox" id="${id}" style="margin-right:6px;"> ${name}
              </label>`;
          }

          return div;
        };

        // コントロールを地図に追加
        xyzControl.addTo(map);

        // 各チェックボックスに動作を設定
        for (const name in xyzOverlays) {
          const checkbox = document.getElementById(`chk-xyz-${name}`);
          checkbox.addEventListener('change', function () {
            if (this.checked) {
              // ✅ チェックON時：レイヤを作成して追加
              activeXYZ[name] = L.tileLayer(xyzOverlays[name], {
                opacity: 0.5,          // 半透明（50%）
                maxZoom: 19,           // 地図全体の最大ズーム
                minNativeZoom: 10,     // データの最小ズーム
                maxNativeZoom: 12,     // データの最大ズーム
                zIndex: 1000,          // ベースマップより前に描画
                crossOrigin: true
              }).addTo(map);
            } else {
              // ❌ チェックOFF時：レイヤ削除（通信も停止）
              if (activeXYZ[name]) {
                map.removeLayer(activeXYZ[name]);
                activeXYZ[name] = null;
              }
            }
          });
        }


        // 8. スケールコントロールの追加
        L.control.scale({
          position: "bottomleft",
          metric: true,
          imperial: false,
        }).addTo(map);

        //9.  ここからGPS追跡機能の実装。50行くらい。
        let gpsEnabled = false; // GPS追跡の状態を管理
        let gpsMarker = null; // 現在地を表示するマーカー
        let watchId = null; // GPS追跡のID
        // GPS追跡のON/OFFを切り替える関数
        function toggleGPS() {
            const gpsButton = document.getElementById('gpsButton');
            if (!gpsEnabled) {
                gpsEnabled = true;
                gpsButton.innerText = '現在地追跡 OFF';

                // GPS追跡を開始
                if (navigator.geolocation) {
                    watchId = navigator.geolocation.watchPosition(
                        (position) => {
                            const { latitude, longitude } = position.coords;

                            // マーカーが存在しない場合は新規作成
                            if (!gpsMarker) {
                                gpsMarker = L.marker([latitude, longitude]).addTo(map);
                                map.setView([latitude, longitude], 16); // 現在地にズーム
                            } else {
                                // マーカーを更新
                                gpsMarker.setLatLng([latitude, longitude]);
                            }
                        },
                        (error) => {
                            alert('現在地を取得できませんでした: ' + error.message);
                        },
                        { enableHighAccuracy: true }
                    );
                } else {
                    alert('このデバイスではGPSがサポートされていません。');
                }
            } else {
                // GPS追跡を停止
                gpsEnabled = false;
                gpsButton.innerText = '現在地追跡 ON';

                if (watchId !== null) {
                    navigator.geolocation.clearWatch(watchId);
                    watchId = null;
                }
                // マーカーを削除
                if (gpsMarker) {
                    map.removeLayer(gpsMarker);
                    gpsMarker = null;
                }
            }
        }
        // ボタンクリックイベントを追加
        document.getElementById('gpsButton').addEventListener('click', toggleGPS);//GPS機能ここまで


        // -------------------------------
        // 中心座標をコピーする処理
        // -------------------------------
        document.getElementById('copyBtn').addEventListener('click', function() {
          const center = map.getCenter(); // 地図の現在中心座標を取得
          const lat = center.lat.toFixed(6); // 緯度（小数点6桁まで）
          const lng = center.lng.toFixed(6); // 経度（小数点6桁まで）
          const text = `${lat}, ${lng}`;     // Googleマップ形式で整形

          // クリップボードへコピー
          navigator.clipboard.writeText(text).then(() => {
            alert(`中心座標をコピーしました：\n${text}\n\n他の地図アプリに貼り付けて使えます\n（検索、お気に入り登録、経路案内等）`);
          }).catch(err => {
            alert('コピーに失敗しました: ' + err);
          });
        });

        // -------------------------------
        // 地図中心座標の表示を更新する処理
        // -------------------------------
        function updateCenterCoords() {
          const c = map.getCenter();
          document.getElementById('lat').textContent = c.lat.toFixed(6);
          document.getElementById('lng').textContent = c.lng.toFixed(6);
        }

        // 地図が移動するたびに中心座標を更新
        map.on('move', updateCenterCoords);

        // 初期表示時にも座標を表示
        updateCenterCoords();

        // -------------------------------
        // 十字マークはCSSで常時表示され、
        // z-indexを9999に設定したため常に最前面に出ます。
        // -------------------------------


        // -------------------------------
        // 「指定座標へ移動」ボタンとカスタムモーダルの処理
        // -------------------------------

        const modal = document.getElementById('coordModal');
        const gotoBtn = document.getElementById('gotoBtn');
        const moveBtn = document.getElementById('moveBtn');
        const cancelBtn = document.getElementById('cancelBtn');
        const coordInput = document.getElementById('coordInput');

        // モーダルを開く
        gotoBtn.addEventListener('click', () => {
          coordInput.value = '';
          modal.style.display = 'flex';
        });

        // モーダルを閉じる
        cancelBtn.addEventListener('click', () => {
          modal.style.display = 'none';
        });

        // 「移動」ボタンが押されたとき
        moveBtn.addEventListener('click', () => {
          const input = coordInput.value.trim();
          const parts = input.split(',');
          if (parts.length !== 2) {
            alert('正しい形式で入力してください（例：35.681236, 139.767125）');
            return;
          }

          const lat = parseFloat(parts[0]);
          const lng = parseFloat(parts[1]);
          if (isNaN(lat) || isNaN(lng)) {
            alert('緯度・経度の数値が正しくありません。');
            return;
          }

          map.setView([lat, lng], map.getZoom());
          modal.style.display = 'none';
        });


      });
    </script>
  </body>
</html>

